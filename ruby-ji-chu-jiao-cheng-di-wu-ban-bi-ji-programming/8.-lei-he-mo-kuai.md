# 8.类和模块

## 8.1类是什么

类（Class）是面向对象中一个重要的术语。

### 8.1.1类和实例

类表示对象的种类，Ruby中的对象一定都属于某一个类。如“字符串”对象实际上是"String"类的对象（实例）

生成新的对象时，一般会用到各个类的`new`方法

当查询对象属于哪个类的时候，我们可以使用`class`方法

当判断对象是否属于某个类时，我们可以用`instance_of?`方法

```ruby
ary = Array.new
p ary 

ary1 = []
str = "Hello World!"

p ary1.class
p ary.instance_of?(Array)
p str.class
```

![](../.gitbook/assets/image%20%28132%29.png)

### 8.1.2继承

通过扩展已定义的类来创建新类称为**继承**。

继承后创建的新类称为**子类（subclass）**,被继承的类称为**父类（superclass）**。

通过继承可以实现以下操作

* **在不影响原有功能的前提下追加新功能**
* **重定义原有功能，是名称相同的方法产生不同的效果**
* **在已有功能的基础上追加处理，扩展已有功能**
* **可以创建多个具有相似功能的类**

BasicObject类是最最基础的类，它定义了作为作为Ruby对象的最基本功能。一般对象所需要的类一般都被定义为Object类。

![](../.gitbook/assets/image%20%2872%29.png)

![](file:///C:\Users\Msile\Documents\Tencent%20Files\243198106\Image\C2C\CD5C4472C4290B0E296935627DBC8007.jpg)

子类和父类是一种“is-a”关系，根据类的关系反向追查对象是否属于某个类时，则可以用`is_a`?方法

```ruby
str = "This is a String"
p str.is_a?(String)   =>true
p str.is_a?(Object)   =>true
```

![](../.gitbook/assets/image%20%286%29.png)

## 8.2创建类

```ruby
class Helloworld    					# 创建class语句
	def initialize(myname = "Ruby")		# initialize方法
		@name = myname					# 初始化实例变量
	end

	def hello 							# 实例方法
		puts "hello #{@name}!"
	end
end

harry = Helloworld.new("Harry")			# 新建实例对象
ruby  = Helloworld.new("ruby")
ruby1  = Helloworld.new

harry.hello       						# 调用方法
ruby.hello
ruby1.hello 
```

![](../.gitbook/assets/image%20%2827%29.png)

### 8.2.1 创建class语句

```text
class 类名
    类的定义
end
# 类名的首字母必须大写
```

### 8.2.2 initialize方法

使用new方法生成新的对象时，Initialize方法会被调用，同时new方法的参数也会原封不动的传给Initialize方法，因此初始化对象时需要的处理一般都写在这个方法中。

```ruby
harry = Helloworld.new("Harry")
# 该行代码是新建一个Helloworld类的对象，并将“Harry”参数传至myname
ruby1  = Helloworld.new
#  如果未指定参数，会使用默认参数
```

### 8.2.3实例对象和实例方法

通过@name = myname这行程序，作为参数传切进来的对象会被赋值给@name，我们把以@开头的变量称为实例变量。引用为初始化的实例变量时返回值为nil。

```ruby
	def initialize(myname = "Ruby")		# initialize方法
		@name = myname					# 初始化实例变量
	end
```

### 8.2.4存取器

Ruby中，从对象外部不能直接访问实例变量或对实例变量赋值，需要通过方法

```ruby
class Helloworld    					
	def initialize(myname = "Ruby")		
		@name = myname					
	end

	def hello 							
		puts "hello #{@name}!"
	end

	def name       # 获取name
		@name
	end
 	
	def name=(value)  #修改name
		@name = value
	end
end

harry = Helloworld.new("Harry")	
p harry.name	# 可以像访问属性一样使用方法
harry.name = "harry"   # 看似是给对象的属性赋值，实际是调用name=(value)方法。
p harry.name
```

![](../.gitbook/assets/image%20%2838%29.png)

当对象有多个实例变量时，如果逐个定义存取器，就会使程序变得难懂也容易写错。为此，Ruby提供了更简便的定义方法attr\_reader、attr\_writer、attr\_accseeor。只要指定实例变量名的符号，Ruby就会自动帮我们定义相应的存取器

| 定义 | 意义 |
| :--- | :--- |
| attr\_reader :name | 只读（定义name方法） |
| attr\_writer :name | 只写（定义name=方法） |
| attr\_accessor :name | 读写（定义以上两个方法） |

```ruby
class Helloworld
    attr_accessor :name
end
```

### 8.2.5 特殊变量self

在实例方法中，可以用self这个特殊的变量来引用方法的接受者。

```ruby
class Helloworld
	attr_accessor :name    					
	def initialize(myname = "Ruby")		
		@name = myname					
	end

	def hello 							
		puts "hello #{@name}!"
	end

	def greet
		puts "Hi I am #{self.name}!"
	end	
end
```

### 8.2.6 类方法

方法的接受者就是类本身（类对象）的方法称为类方法。

1.在`class << 类名 ~ end`这个特殊定义中，定义实例方法的形式来定义类方法

此种方法定义的方法称为单例方法

```ruby
class Helloworld
	attr_accessor :name    					
	def initialize(myname = "Ruby")		
		@name = myname					
	end

	def hello 							
		puts "hello #{@name}!"
	end
end
class << Helloworld
	def hello(name)
		puts "#{name} said HelloWorld!"
	end
end
Helloworld.hello("Harry")
```

![](../.gitbook/assets/image%20%2839%29.png)

2..在`class <<self ~end`这个特殊定义中，定义实例方法的形式来定义类方法

```ruby
class Helloworld
	class << self
		def hello(name)
			puts "#{name} said Helloworld!"
		end
	end
end

Helloworld.hello("Harry")
```

![](../.gitbook/assets/image%20%2864%29.png)

  
3.在`def 类名.方法名 ~ end`这个特殊定义中，定义实例方法的形式来定义类方法

```ruby
class Helloworld
	attr_accessor :name    					
	def initialize(myname = "Ruby")		
		@name = myname					
	end
end

def Helloworld.hello(name)
	puts "#{name} said Helloworld!"
end

Helloworld.hello("Harry")
```

![](../.gitbook/assets/image%20%283%29.png)

4.在`def 类名.方法名 ~ end`这个特殊定义中，也可以在类定义使用self定义实例方法的形式来定义类方法

```ruby
class Helloworld
	attr_accessor :name    					
	def initialize(myname = "Ruby")		
		@name = myname					
	end

	def self.hello(name)
		puts "#{name} said hello"
	end
end

Helloworld.hello("Harry")
```

![](../.gitbook/assets/image%20%2853%29.png)

### 8.2.7 常量

在class语句中可以定义常量

```ruby
class Helloworld
	Version = "1.0"
end

p Helloworld::Version
```

![](../.gitbook/assets/image%20%2866%29.png)

### 8.2.8 类变量

以@@开头的变量称为，类变量。类变量是该类所有实例的共享变量，这一点与常量相似，不同的是类变量的值可以多次修改。但是类变量不能使用存取器，所以需要直接定义。

```ruby
class HelloCount
	@@count = 0

	def HelloCount.count
		@@count
	end

	def initialize(myname="Ruby")
		@name = myname
	end

	def hello
		@@count+=1
		puts " Hello I am #{@name}!"
	end
end

Harry = HelloCount.new("Harry")
ruby  = HelloCount.new("ruby")
ruby1  = HelloCount.new
p HelloCount.count
Harry.hello
ruby.hello
ruby1.hello
p HelloCount.count
```

![](../.gitbook/assets/image%20%2882%29.png)

### 8.2.9 限制方法的调用

Ruby提供了3种方法的访问级别：

* **public**   ： 以实例方法的形式向外部公开该方法（在没有指定访问级别时默认为public，但initialize通常会被定义为private）
* **private**  ：在指定接收者的情况下，不能调用该方法（只能使用缺省接收者的方法调用该方法，因此无法从实例的外部访问）
* **protected**  ：在同一个类中时可将该方法作为实例方法调用

```ruby
class AccTest
	def pub
		puts "pub is a public method."
	end

	public :pub  #把pub方法指定为public（可省略）

	def priv
		puts "pub is a private method."
	end

	private :priv #把priv方法指定为private

end
acc = AccTest.new 
acc.pub           # 可正常调用
acc.priv          # 会报错
```

![](../.gitbook/assets/image%20%28110%29.png)

希望统一定义多个方法的访问级别时，可以使用下面的语法

```ruby
class AccTest
	def pub 	# 默认为Public
		puts "pub is a public method."
	end

	private   # 以下的方法都被定义为private

	def priv
		puts "pub is a private method."
	end
end
acc = AccTest.new 
acc.pub           # 可正常调用
acc.priv          # 会报错
```

定义为protected的方法，在同一个类（及其子类）中可作为实例方法调用，而在除此以外的地方则无法使用。

```ruby
class Point
	attr_accessor :x,:y
	protected :x=,:y=

	def initialize(x=0.0,y=0.0)
		@x,@y = x,y
	end
	def swap(other)
		tmp_x,tmp_y = @x,@y
		@x,@y = other.x,other.y
		other.x,other.y = tmp_x,tmp_y

		return self
	end
end
p0 = Point.new
p1 = Point.new(1.0,2.0)

p [p0.x, p0.y]
p [p1.x, p1.y]

p0.swap(p1)
p [p0.x, p0.y]
p [p1.x, p1.y]

# p0.x = 10.0    #会报错，x=为protected
```

![](../.gitbook/assets/image%20%2852%29.png)

## 8.3 扩展类

### 8.3.1 在原有类的基础上添加方法

Ruby允许我们在已经定义好的类中添加方法。

```ruby
class String
	def count_word
		ary = self.split(/\s+/)  # 用空格分隔self
								 # 分解成数组
		return ary.size			 # 返回分隔后的数组的元素总数
	end
end

str = "Let us Just Be Friend"
p str.count_word
```

![](../.gitbook/assets/image%20%28100%29.png)

### 8.3.2 继承

```text
# 继承语法：
class 类名<父类名
    类定义
end
```

利用继承，我们可以把共同的功能定义在父类，把各自独有的功能定义在子类。

定义类时，如果没有指定父类，Ruby会默认该类为Object类的子类

```ruby
class RingArray < Array # 指定父类
	def [] (i)        	# 重定义运算符[]
		idx = i%size    # 计算新索引值
		super(idx)      # 调用父类中同名的方法
	end
end

weekday = RingArray["一","二","三","四","五","六","日"]

p weekday[6]
p weekday[11]
p weekday[15]
p weekday[-1]
```

![](../.gitbook/assets/image%20%2831%29.png)

## 8.4 alias 与 undef

### 8.4.1 alias

有时我们希望给已存在的方法设置别名，这时候就需要用到alias方法。

```text
alias 别名 原名   # 直接使用方法名
alias :别名 :原名 # 使用符号名
```

```ruby
# 定义了类C1及其子类C2，在类C2中，
# 对hello方法设置别名old_hello后，重定义了hello方法
class C1
	def hello
		"Hello"
	end
end

class C2<C1
	alias old_hello hello
	def hello
		"#{old_hello},again"
	end
end

obj = C2.new
p obj.old_hello
p obj.hello

```

![](../.gitbook/assets/image%20%2841%29.png)

### 8.4.2 undef

undef用于删除已定义的方法。与alias一样，参数可以指定方法名或者符号名

```text
undef 方法名  # 直接使用方法名
undef :方法名 # 使用符号名
```

在子类中希望删除父类定义的方法时可以使用undef

## 8.5 单例类 （singleton class / eigenclass）

```ruby
# hello只是str1的方法
str1 = "Ruby"
str2 = "ruby"

class << str1
	def hello
		"Hello #{self}"
	end
end
p str1.hello
# p str2.hello   # 会报错（NoMethodError）
```

![](../.gitbook/assets/image%20%2893%29.png)

Ruby中所有的类都是Class类的对象，因此Class类的实例方法以及类对象所添加的单例方法都是类方法。

## 8.6 模块是什么

模块是Ruby的特色功能之一。如果说类表现的是食物的实体（数据）及其行为（处理），那么模块表现的就只是事物的行为部分。模块鱼类有以下两点不同：

* **模块不能拥有实例**
* **模块不能被继承**

## 8.7 模块的使用方法

### 8.7.1 利用Mix-in扩展功能

Mix-in就是将模块混合到类中。在定义类时使用Include，模块中的方法、常量就能被类使用。

Mix-in可以灵活地解决下面的问题

* **虽然两个类拥有相似的功能，但是不希望它们作为相同的类来考虑**
* **Ruby不支持父类的多重继承，因此无法对已经继承的类添加共通的功能**

```ruby
module MyMoudle
	# 共同的方法等
end

class Myclass1
	include MyMoudle
	# Myclass1中独有的方法
end

class Myclass2
	include MyMoudle
	# Myclass2中独有的方法
end
```

### 8.7.2 提供命名空间

**命名空间（namespace）**就是对方法、常量、类等名称进行区分及管理的单位。模块提供各自独立的命名空间，因此不同模块的的同名方法会被程序认为是两个不同的方法，同名常量也会被认为不同常量，因此通过在模块中定义名称，可以解决命名冲突的问题。

